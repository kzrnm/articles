---
title: BigInteger(任意精度整数) の乗算・除算・文字列処理
emoji: "🚄"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: 
 - "csharp"
 - "dotnet"
 - 多倍長整数
 - "Burnikel-Ziegler 法"
 - 競技プログラミング
published: false
---

# BigInteger について

いわゆる「任意精度整数」「多倍長整数」は .NET では `System.Numerics.BigInteger` 型として実装されています。

https://learn.microsoft.com/ja-jp/dotnet/api/system.numerics.biginteger

ただ、実装に改善の余地が大きく存在したのでいくつか Pull Request を出しました。

BigInteger の計算について説明しつつ、それらの Pull Request を説明していきます。

以下の計算量の説明では桁数を $n$ とすることにします。また 基数を $\beta$ とします。$2$ 進数ならば $\beta=2$, $10$ 進数ならば $\beta=10$ です。

また、[競技プログラミングでも使えるよう改造したもの](https://github.com/kzrnm/BigInteger/)も公開しています。

## BigInteger の乗算

BigInteger の乗算は [カラツバ法](https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%A9%E3%83%84%E3%83%90%E6%B3%95) で実装されています。

ただしく実装されていれば $O(n^{\log_2 3})$ で計算することができます。

ちなみに、BigInteger の乗算については [Toom–Cook 乗算](https://en.wikipedia.org/wiki/Toom%E2%80%93Cook_multiplication) $O(n^{\log_3 5})$ や FFT $O(n \log_n)$ での畳み込みでより最適化する余地もありますが、ひとまずここでは実装していません。

### カラツバ法の概要

$n$ 桁の整数 $A, B$ の乗算を考えます。

整数 $A$ の下位 $n/2$ 桁を $A_0$、上位 $n/2$ 桁を $A_1$ とします。$B$ についても同様に $B_0, B_1$ とします。

この積を $Z = AB$ とすると $n/2$ 桁ごとの乗算で $Z$ を計算することができます。

$$
\begin{aligned}
Z &= AB \\
&= (A_0 + A_1 \beta^{n/2}) (B_0 + B_1 \beta^{n/2}) \\
&= (A_1 + B_1) \beta^n + (A_1 B_0 + A_0 B_1) \beta^{n/2} + (A_0 + B_0)
\end{aligned}
$$

```text
|                 |                 |       A_1       |       A_0       |
|                 |                 |       B_1       |       B_0       |

Z
|                 |                 |             A_0 * B_0             |
|                 |       A_1 * B_0 + A_0 * B_1       |                 |
|             A_1 * B_1             |                 |                 |
```

愚直な実装だと、加減算は $O(n)$、乗算は $O(n^2)$ となるので $(n/2)^2 \times 4 = n^2$ となり、このままでは特に改善にはなりません。

しかし、$A_1 B_0 + A_0 B_1$ を下記のように式変形すると事情が変わってきます。

$$
\begin{aligned}
& A_1 B_0 + A_0 B_1 \\
&= (A_1 B_0 + A_0 B_1 + A_0 B_0 + A_1 B_1) - A_0 B_0 - A_1 B_1 \\
&= (A_0 + A_1) (B_0+B_1) - A_0 B_0 - A_1 B_1 \\
\end{aligned}
$$

$A_0 B_0, A_1 B_1, (A_0 + A_1) (B_0+B_1)$ の 3 回の乗算と加減算で積を求めることが出来ます。再帰的に適用することで、乗算の計算量を $O(n^{\log_2 3})$ とすることができます。

### カラツバ法の実例

$10$ 進数 $8$ 桁の乗算をしてみます。

適当に $A=47948571, B=13636632, Z=653857017652872$ とします。

$$
\beta^n = 100000000 \\
\beta^{n/2} = 10000 \\
A_0=8571 \\
A_1=4794 \\
B_0=6632 \\
B_1=1363
$$

より

$$
\begin{aligned}
A_0 B_0 &=& 56842872\\
A_1 B_1 &=& 6534222\\
(A_0 + A_1 = 13365) (B_0+B_1=7995) &=& 106853175
\end{aligned}
$$

$$
\begin{aligned}
Z &= (A_1 + B_1) \beta^n + (A_1 B_0 + A_0 B_1) \beta^{n/2} + (A_0 + B_0) \\
&= 6534222 \times 100000000 + (106853175-6534222-56842872) \times 10000 + 56842872 \\
&= 653422200000000 + 434760810000 + 56842872 \\
&= 653857017652872 \\
\end{aligned}
$$

### カラツバ法での乗算のバグ

- https://github.com/dotnet/runtime/pull/92208
- https://github.com/dotnet/runtime/pull/98587

.NET 8 までの実装にはバグがありました。

$n \ge m$ として $n$ 桁と $m$ 桁の乗算をするときは、$n/2$ 桁で分割しなければならないのですが、$m/2$ 桁で分割されてしまっていました。

そのため、桁数の差があるときに非常に遅くなってしまう実装になっていました。

変更前は $10^6$ 桁同士の乗算が 1.2 秒程度だったのに対して、$10^6$ 桁と $10^5$ 桁の乗算は 5 秒ほどかかってしまう遅さだったのですが、$10^6$ 桁と $10^5$ 桁の乗算が 450 ミリ秒 程度で終わるよう大幅に改善されました。

## BigInteger の除算

除算は乗算よりかなりややこしいです。愚直な実装での計算量は $O(n^2)$ ですが、乗算よりも重めです。

この除算の計算を乗算に落とし込んで $O(K(n) + n \log n)$ ($K(n)$ は乗算の計算量) で計算するアルゴリズムが考案されていたりします。

競技プログラミングでの実装はニュートン法で実装している人が多い印象です。

参考: [競プロでの提出例](https://judge.yosupo.jp/submissions/?problem=division_of_big_integers&status=AC&order=-id&page=0&pagesize=100)

しかし、実用されているアルゴリズムだと **Burnikel-Ziegler 法** が主流のようです。ざっと調べただけで 3 つヒットしました。GitHub で公開されてないものもあったりしそうなので広く使われていそうです。

- [Golang](https://github.com/golang/go/issues/21960)
- [OpenJDK](https://github.com/openjdk/jdk/blob/be900f1253fe130347385f0daec772c20a79ed57/src/java.base/share/classes/java/math/MutableBigInteger.java#L1246)
- [JavaScript-V8](https://github.com/v8/v8/blob/7fdc2728f2114b083ebbd24710a32fe4574c0c57/src/bigint/div-burnikel.cc)

よって、Burnikel-Ziegler 法での実装での PR を出しました。

- https://github.com/dotnet/runtime/pull/96895

### Burnikel-Ziegler 法

論文 [Fast Recursive Division](https://citeseerx.ist.psu.edu/pdf/c9d46de024099fb3fbd44030ddfba1561738939e) の内容に基づきます。

$r$ 桁の整数 $A$ を $s$ 桁の整数 $B$ で割る除算を考えます。商を $Q$、あまりを $R$ とします。

ここで $r \ge s$ とします。$r \lt s$ ならば自明に $Q=0, R=A$ です。

また、下記のような表記を導入します。

$$
\begin{aligned}
A &= [A_2, A_1, A_0] = A_2 \beta^{2n/3} + A_1 \beta^{n/3} + A_0 \\
A &= [A_1, A_0] = A_1 \beta^{n/2} + A_0
\end{aligned}
$$

- $[A_3, A_2, A_1]$ と書いたときは $A$ の桁数 $n$ が $3$ の倍数であり、下位 $n/3$ 桁を $A_0$、その次の $n/3$ 桁を $A_1$、上位 $n/3$ 桁を $A_2$ とする。
- $[A_2, A_1]$ と書いたときは $A$ の桁数 $n$ が $2$ の倍数であり、下位 $n/2$ 桁を $A_0$、上位 $n/2$ 桁を $A_1$ とする。

という具合です。

#### 桁が小さいとき・桁の差が小さいときの除算(愚直な計算)

$B$ の桁が小さいとき、または $A, B$ の桁の差が小さいときは上の方の桁から順に商を確定させていく計算筆算式の愚直な計算でやります。計算量は $O(n^2)$ です。

$B$ が $DIV\_LIMIT$ 桁以下ならば愚直計算するということにします。 $DIV\_LIMIT$ の決め方は ベンチマークに基づくのが良いでしょう。自分の計測だと $32$ になりました。

#### $2n$ 桁 / $n$ 桁の除算

$r \le 2n, s=n$ となるときの除算です。といっても $n$ は偶数でなければならないので $l=4p, m=2p$ 桁と考える方が良いかもしれません。また、$A \lt B \beta^n$ 、言い換えると 商 $Q$ が $n$ 桁以下である必要があります。

$n$ が奇数だったり $DIV\_LIMIT$ 以下だったりするときは愚直に計算します。

そうでなければ、$A=[A_3,A_2,A_1,A_0], B=[B_1,B_0], Q=[Q_1,Q_0]$ として次のように考えます。

1. $3n$ 桁 / $2n$ 桁の除算により $[A_3,A_2,A_1] = Q_1 B + S$ となる $Q_1, S$ を求める。
2. $3n$ 桁 / $2n$ 桁の除算により $[S_1,S_0,A_0] = Q_0 B + R$ となる $Q_0, R$ を求める。

```text
A/B を考える
|       A_3       |       A_2       |       A_1       |       A_0       |
|                 |                 |       B_1       |       B_0       |

[A_3,A_2,A_1]/B
|       A_3       |       A_2       |       A_1       |
=
|                        Q_1 B                        |
|                 |       S_1       |       S_0       |

[S_1,S_0,A_0]/B
|                 |       S_1       |       S_0       |       A_0       |
=
|                 |                        Q_0 B                        |
|                 |                 |       R_1       |       R_0       |
```

このように 2 回の $3n$ 桁 / $2n$ 桁の除算に落とし込むことで計算できます。

#### $3n$ 桁 / $2n$ 桁の除算

$r \le 3n, s=2n$ となるときの除算です。

以下、$A=[A_2,A_1,A_0], B=[B_1,B_0]$ として考えます。

$A \lt B \beta^n$ すなわち 商 $Q$ が $n$ 桁以下である必要があります。分割形式で表すと $[A_2,A_1] \lt [B_1,B_0]$ です。

1. 商の概算 $\widehat{Q}$ を求める

$Q \le \widehat{Q} \le Q+2$ であるような $\widehat{Q}$ を求めます。

- $A_2 \lt B_1$ ならば $\widehat{Q} = [A_2, A_1]/B_1$ ($2n$ 桁 / $n$ 桁の除算)
- $A_2 \ge B_1$ ならば $\widehat{Q} = \beta^n - 1$
  - $A \lt B \beta^n$ なのだから $A_2 \gt B_1$ にはならない気がする

また、$S = [A_2, A_1] - \widehat{Q} B_1$ となるような $S$ を求めます。言い換えると、$S$ は $[A_2, A_1]/B_1$ のあまりです。

2. あまりの概算 $\widehat{R}$ を求める

まず

$$
D = \widehat{Q} B_2
$$

を導出します。$A_2 \ge B_1$ のときは $D = B_2 \beta^n - B_2$ とすると良いです。

すると

$$
\widehat{R} = S \beta^n + A_0 - D
$$

として、あまりの概算が求められます。

3. 実際の商とあまりの導出

$Q \le \widehat{Q} \le Q+2$ と \widehat{Q} は実際の商より少し大きい可能性があります。

$Q \lt \widehat{Q}$ のときは $\widehat{R}$ が負の値となっているので

```cs
// 擬似コード
// 実際には配列で保持されている
R_hat = S * pow(β, n) + A_0 - D;
while(R_hat < 0)
{
    R_hat += B;
    Q_hat++;
}
```

というようなロジックを記述して、$\widehat{Q}, \widehat{R}$ を実際の $Q, R$ にします。

4. 補足

実際の値は配列で保持しているため、値は符号なしの非負整数として扱いたいです。そのため、「$\widehat{R}$ が負」という条件でループするのは避けたほうがよいです。

実際には下記のようにするのが良いでしょう。

```cs
// 擬似コード
// 実際には配列で保持されている
R_hat = S * pow(β, n) + A_0;
while(R_hat < D)
{
    R_hat += B;
    Q_hat++;
}
R_hat -= D;
```

```text
A/B を考える
|       A_2       |       A_1       |       A_0       |
|                 |       B_1       |       B_0       |

A=QB+R
|               Q B_1               |                 |
|                 |               Q B_2               |
+
|                 |                 R                 |
```

#### 任意桁の除算

$2n$ 桁 / $n$ 桁の除算と $3n$ 桁 / $2n$ 桁の除算が再帰的に実行できるようになったので、任意の桁の除算を $2n$ 桁 / $n$ 桁の除算に落とし込むことで計算できるようにします。

1. $A, B$ を正規化する

$B$ の桁数を計算しやすいように増やします。

下記のような数 $n$ を求めます。

$k$ を $2^k \times DIV\_LIMIT > s$ をみたす最小の整数とします。また、$m=2^k$とします。

$s$ 以上で最小の $m$ の倍数 $n$ を求めます。

$$
\begin{aligned}
m &= min\{2^k|2^k \times DIV\_LIMIT > s\} \\
j &= \lceil s/m \rceil \\
n &= j \times m
\end{aligned}
$$

※各変数の解説

$2^k \times DIV\_LIMIT > s$ は「愚直計算に移行するまでに $k$ 回分割できる長さ」を表します。

Burnikel-Ziegler 法では除数の桁数を半分ずつに分割していくので $2$ の冪乗にすると都合が良いです。

$DIV\_LIMIT = 5$ での例を挙げてみます。

除数の桁数が $24, 26, 28, 32$ の場合をそれぞれ考えると

- 24 桁で除算
  - 分割して 12 桁で除算
  - 分割して 6 桁で除算
  - 分割して 3 桁で除算: 奇数なので/ $DIV\_LIMIT$ を下回ったので愚直計算
- 26 桁で除算
  - 分割して 13 桁で除算: 奇数なので愚直計算
- 28 桁で除算
  - 分割して 14 桁で除算
  - 分割して 7 桁で除算: 奇数なので愚直計算
- 32 桁で除算
  - 分割して 16 桁で除算
  - 分割して 8 桁で除算
  - 分割して 4 桁で除算: $DIV\_LIMIT$ を下回ったので愚直計算

と桁数が $8$ の倍数のときには、愚直計算する桁数が $DIV\_LIMIT$ を下回ります。

この $8$ に相当するのが $m$ です。

**$B$ の桁数を $m$ の倍数である $n$ にする** のが目的です。

$B$ を $\sigma = n - s$ 桁だけ大きくするため、$B$ を $B\times \beta^\sigma$ で置き換えます。基数 $\beta$ が $\beta=2$ ならばビットシフトで補正可能です。

同様に $A$ も $A\times \beta^\sigma$ で置き換えます。

2. $A$ を分割

以下のような $t$ を求めます。

- $A \lt \dfrac{\beta^{n}}{2}$ ならば $t=2$ とします
- そうでなければ、$A \lt \dfrac{\beta^{l  n}}{2}$ をみたす最小の整数 $l$ について $t=l$ とします

$A$ を $n$ 桁ごとに分割して $[A_{t-1}, ..., A_0]$ と置きます。$A_{t-1}$ については桁数が $n$ 未満となります。

$A_{t-1}$ の桁数が $n$ 未満となるように $t$ を置くのは $2n$ 桁 / $n$ 桁の除算で $A\lt B \beta^n$ という条件を満たすためです。

3. 計算する

上位の桁から順にあまりを求めていきます。

```cs
// 擬似コード
// 実際には配列で保持されている
Z[t-2] = [A[t-1], A[t-2]];
Q[t-2] = Z[t-2] / B;
R[t-2] = Z[t-2] % B;
for(int i = t-3; i>=0; i--)
{
    Z[i] = [R[i+1], A[i]];
    Q[i] = Z[i] / B;
    R[i] = Z[i] % B;
}
```

```text
A/B を考える
|     A_{t-1}     |     A_{t-2}     |     A_{t-3}     |       ...       |       A_0       |
|                 |        B        |

|     A_{t-1}     |     A_{t-2}     |     A_{t-3}     |       ...       |       A_0       |
|             B Q_{t-2}             |       ...       |       ...       |       A_0       |

|                 |     R_{t-2}     |     A_{t-3}     |       ...       |       A_0       |
|                 |             B Q_{t-3}             |       ...       |       A_0       |

|                                          ...        |       R_1       |       A_0       |
|                                          ...        |               B Q_0               |

|                                          ...                          |       R_0       |
```

求める商は $Q=[Q_{t-2}, ..., Q_0]$、あまりは$R_0$ になります。

ただし、$A, B$ を $\beta^\sigma$ だけ補正していることから、真に求めるあまり $R$ は $R_0/\beta^\sigma$ です。

## string ⇄ BigInteger

BigInteger は `UInt32` 配列で実装されているため、$2^32$ 進数とみなせます。そのため、$2$ 進数や $16$ 進数の文字列ならば容易に変換可能です。

しかし、$10$ 進数の文字列との変換はそれなりに難しいです。どちらの計算についても愚直計算では $O(n^2)$ かかります。

[Divide-and-Conquer アルゴリズム](http://www.numberworld.org/y-cruncher/internals/radix-conversion.html) で計算すると、乗算・除算の計算量を $M(n)$ として $O(K(n)\log(n))$ で計算できます。

### Divide-and-Conquer アルゴリズム

あらかじめ、$10^{k 2^n}$ を計算しておきます。

string → BigInteger の変換では $k 2^n$ 桁で文字列を分割してパース、上位に $10^{k 2^n}$ をかける。

BigInteger → string の変換では、$10^{k 2^n}$ で割った商を上位の $k 2^n$ 桁、あまりを下位の $k 2^n$ 桁として再帰的に変換します。

`BigInteger.Parse` (string → BigInteger の変換) は[実装済み](https://github.com/dotnet/runtime/pull/55121)です。

ただし、愚直計算の閾値が大きすぎたので閾値の計算によって $20000$ 桁の文字列のパースでは2倍ほど速くなりました。

- https://github.com/dotnet/runtime/pull/96538

`BigInteger.ToString` (BigInteger → string の変換) は除算の計算量の改善が必要なので除算の改善後に PR 

- TODO: 