---
title: "ã€C#ã€‘å…±é€šéµæš—å·ã§ã®æš—å·åŒ–(DOBON.NETäº’æ›)"
emoji: "ğŸ˜Š"
type: "tech"
topics:
  - "csharp"
published: true
published_at: "2022-08-26 18:50"
---

# å…±é€šéµæš—å·ã§ã®æš—å·åŒ–

**For: C# ã§å…±é€šéµæš—å·ã‚’ä½¿ã„ãŸã„äºº**

å›½å†…ã§ã¯[DOBON.NET](http://dobon.net/vb/dotnet/string/encryptstring.html) ã®æ‰‹æ³•ãŒç”¨ã„ã‚‰ã‚Œã‚‹ã“ã¨ã‚‚å¤šã„ã¨æ€ã„ã¾ã™ãŒã€ç¾åœ¨ã§ã¯ `System.Security.Cryptography.RijndaelManaged` ãŒ `Obsolete` ã«ãªã£ã¦ã„ã‚‹ã®ã§å¯¾å‡¦æ³•ã‚’è¨˜è¿°ã—ã¾ã™ã€‚


## DOBON.NET äº’æ›ã®æš—å·åŒ–

å®Ÿã¯ `System.Security.Cryptography.RijndaelManaged` ã‚’ `System.Security.Cryptography.Aes.Create()` ã«ç½®ãæ›ãˆã‚‹ã ã‘ã§äº’æ›ã®ã‚ã‚‹å‹•ä½œã«ãªã‚Šã¾ã™ã€‚

```csharp
static class Crypt
{
    static void Main()
    {
        const string input = "Input String æ–‡å­—åˆ—";
        const string password = "password";

        var rijndael = new System.Security.Cryptography.RijndaelManaged();
        var aes = System.Security.Cryptography.Aes.Create();

        string encryptedRijndael = rijndael.EncryptString(input, password);
        string encryptedAes = aes.EncryptString(input, password);
        Console.WriteLine($"Rijndael: {encryptedRijndael}");
        Console.WriteLine($"     Aes: {encryptedAes}");

        Console.WriteLine(rijndael.DecryptString(encryptedRijndael, password));
        Console.WriteLine(aes.DecryptString(encryptedRijndael, password));
    }

    /// <summary>
    /// æ–‡å­—åˆ—ã‚’æš—å·åŒ–ã™ã‚‹
    /// </summary>
    /// <param name="sourceString">æš—å·åŒ–ã™ã‚‹æ–‡å­—åˆ—</param>
    /// <param name="password">æš—å·åŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</param>
    /// <returns>æš—å·åŒ–ã•ã‚ŒãŸæ–‡å­—åˆ—</returns>
    public static string EncryptString(this SymmetricAlgorithm algorithm, string sourceString, string password)
    {
        //ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰å…±æœ‰ã‚­ãƒ¼ã¨åˆæœŸåŒ–ãƒ™ã‚¯ã‚¿ã‚’ä½œæˆ
        byte[] key, iv;
        GenerateKeyFromPassword(
            password, algorithm.KeySize, out key, algorithm.BlockSize, out iv);
        algorithm.Key = key;
        algorithm.IV = iv;

        //æ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆå‹é…åˆ—ã«å¤‰æ›ã™ã‚‹
        byte[] strBytes = System.Text.Encoding.UTF8.GetBytes(sourceString);

        //å¯¾ç§°æš—å·åŒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
        System.Security.Cryptography.ICryptoTransform encryptor =
            algorithm.CreateEncryptor();
        //ãƒã‚¤ãƒˆå‹é…åˆ—ã‚’æš—å·åŒ–ã™ã‚‹
        byte[] encBytes = encryptor.TransformFinalBlock(strBytes, 0, strBytes.Length);
        //é–‰ã˜ã‚‹
        encryptor.Dispose();

        //ãƒã‚¤ãƒˆå‹é…åˆ—ã‚’æ–‡å­—åˆ—ã«å¤‰æ›ã—ã¦è¿”ã™
        return System.Convert.ToBase64String(encBytes);
    }

    /// <summary>
    /// æš—å·åŒ–ã•ã‚ŒãŸæ–‡å­—åˆ—ã‚’å¾©å·åŒ–ã™ã‚‹
    /// </summary>
    /// <param name="sourceString">æš—å·åŒ–ã•ã‚ŒãŸæ–‡å­—åˆ—</param>
    /// <param name="password">æš—å·åŒ–ã«ä½¿ç”¨ã—ãŸãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</param>
    /// <returns>å¾©å·åŒ–ã•ã‚ŒãŸæ–‡å­—åˆ—</returns>
    public static string DecryptString(this SymmetricAlgorithm algorithm, string sourceString, string password)
    {
        //ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰å…±æœ‰ã‚­ãƒ¼ã¨åˆæœŸåŒ–ãƒ™ã‚¯ã‚¿ã‚’ä½œæˆ
        byte[] key, iv;
        GenerateKeyFromPassword(
            password, algorithm.KeySize, out key, algorithm.BlockSize, out iv);
        algorithm.Key = key;
        algorithm.IV = iv;

        //æ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆå‹é…åˆ—ã«æˆ»ã™
        byte[] strBytes = System.Convert.FromBase64String(sourceString);

        //å¯¾ç§°æš—å·åŒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
        System.Security.Cryptography.ICryptoTransform decryptor =
            algorithm.CreateDecryptor();
        //ãƒã‚¤ãƒˆå‹é…åˆ—ã‚’å¾©å·åŒ–ã™ã‚‹
        //å¾©å·åŒ–ã«å¤±æ•—ã™ã‚‹ã¨ä¾‹å¤–CryptographicExceptionãŒç™ºç”Ÿ
        byte[] decBytes = decryptor.TransformFinalBlock(strBytes, 0, strBytes.Length);
        //é–‰ã˜ã‚‹
        decryptor.Dispose();

        //ãƒã‚¤ãƒˆå‹é…åˆ—ã‚’æ–‡å­—åˆ—ã«æˆ»ã—ã¦è¿”ã™
        return System.Text.Encoding.UTF8.GetString(decBytes);
    }

    /// <summary>
    /// ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰å…±æœ‰ã‚­ãƒ¼ã¨åˆæœŸåŒ–ãƒ™ã‚¯ã‚¿ã‚’ç”Ÿæˆã™ã‚‹
    /// </summary>
    /// <param name="password">åŸºã«ãªã‚‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</param>
    /// <param name="keySize">å…±æœ‰ã‚­ãƒ¼ã®ã‚µã‚¤ã‚ºï¼ˆãƒ“ãƒƒãƒˆï¼‰</param>
    /// <param name="key">ä½œæˆã•ã‚ŒãŸå…±æœ‰ã‚­ãƒ¼</param>
    /// <param name="blockSize">åˆæœŸåŒ–ãƒ™ã‚¯ã‚¿ã®ã‚µã‚¤ã‚ºï¼ˆãƒ“ãƒƒãƒˆï¼‰</param>
    /// <param name="iv">ä½œæˆã•ã‚ŒãŸåˆæœŸåŒ–ãƒ™ã‚¯ã‚¿</param>
    static void GenerateKeyFromPassword(string password,
       int keySize, out byte[] key, int blockSize, out byte[] iv)
    {
        //ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰å…±æœ‰ã‚­ãƒ¼ã¨åˆæœŸåŒ–ãƒ™ã‚¯ã‚¿ã‚’ä½œæˆã™ã‚‹
        //saltã‚’æ±ºã‚ã‚‹
        byte[] salt = System.Text.Encoding.UTF8.GetBytes("saltã¯å¿…ãš8ãƒã‚¤ãƒˆä»¥ä¸Š");
        //Rfc2898DeriveBytesã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹
        System.Security.Cryptography.Rfc2898DeriveBytes deriveBytes =
            new System.Security.Cryptography.Rfc2898DeriveBytes(password, salt);
        //.NET Framework 1.1ä»¥ä¸‹ã®æ™‚ã¯ã€PasswordDeriveBytesã‚’ä½¿ç”¨ã™ã‚‹
        //System.Security.Cryptography.PasswordDeriveBytes deriveBytes =
        //    new System.Security.Cryptography.PasswordDeriveBytes(password, salt);
        //åå¾©å‡¦ç†å›æ•°ã‚’æŒ‡å®šã™ã‚‹ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§1000å›
        deriveBytes.IterationCount = 1000;

        //å…±æœ‰ã‚­ãƒ¼ã¨åˆæœŸåŒ–ãƒ™ã‚¯ã‚¿ã‚’ç”Ÿæˆã™ã‚‹
        key = deriveBytes.GetBytes(keySize / 8);
        iv = deriveBytes.GetBytes(blockSize / 8);
    }
}
```