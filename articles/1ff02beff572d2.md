---
title: "ã€ç«¶ãƒ—ãƒ­ã€‘C#: ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç’°å¢ƒæ§‹ç¯‰ 2022å¹´ç‰ˆ"
emoji: "ğŸ"
type: "tech"
topics:
  - "dotnet"
  - "ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°"
  - "ç«¶ãƒ—ãƒ­"
published: true
published_at: "2022-02-23 21:49"
---

ä»¥å‰ã€Qiita ã§åŒæ§˜ã®è¨˜äº‹ã‚’æ›¸ã„ã¦ã„ãŸã®ã§ã™ãŒã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¦ã¾ã‚‹ã”ã¨æ¶ˆãˆã¦ã—ã¾ã£ãŸã®ã§æ–°ãŸã«ä½œã‚Šç›´ã™ã“ã¨ã«ã—ã¾ã™ã€‚

# C# ã§ã®ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç’°å¢ƒæ§‹ç¯‰

æ§‹ç¯‰ã™ã‚‹ã‚‚ã®
- ãƒ­ãƒ¼ã‚«ãƒ«ã§ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å®Ÿè¡Œã‚’ã§ãã‚‹
- AtCoder ãªã©ã®ã‚³ãƒ³ãƒ†ã‚¹ãƒˆã‚µã‚¤ãƒˆã«æŠ•ç¨¿ã™ã‚‹

æœ¬è¨˜äº‹ã§ã¯ä¸Šè¨˜ã®2ç‚¹ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

ã‚ˆã‚Šä¾¿åˆ©ãªç’°å¢ƒæ§‹ç¯‰ã‚’ç›®æŒ‡ã™ãªã‚‰ã°ç§ã®ä½¿ç”¨ã—ã¦ã„ã‚‹ç’°å¢ƒã‚’å‚è€ƒã«ã•ã‚Œã‚‹ã®ã‚‚è‰¯ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
https://github.com/kzrnm/Kzrnm.Competitive/
## 1. ãƒ©ã‚¤ãƒ–ãƒ©ãƒªä¸è¦ã®å•é¡Œã‚’æå‡ºã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã¾ã§
### IDE (Visual Studio) ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

ã¾ãšã¯ IDE ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚

ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ã„ã†ã“ã¨ã§éå•†ç”¨åˆ©ç”¨ãªã¯ãšãªã®ã§ã€Visual Studio Community ã‚’ä½¿ã„ã¾ã™ã€‚

https://visualstudio.microsoft.com/ja/vs/community/

Visual Studio Code ã§ã‚‚ã§ãã‚‹ã¨ã¯æ€ã„ã¾ã™ãŒã€ãƒ‡ãƒãƒƒã‚°å®Ÿè¡Œãªã©ã§ä¾¿åˆ©ãªã®ã§ Visual Studio ã‚’æ¨å¥¨ã—ã¾ã™ã€‚

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ

Visual Studio ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãŸã‚‰ã€ã€Œæ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã€ã‹ã‚‰å®Ÿè¡Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚

C# ã®ã€Œã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚¢ãƒ—ãƒªã€ã‚’é¸ã³ã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/cb4deecf2872-20220223.png)

ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ AtCoder ã‚„ Codeforces ã§ä½¿ç”¨å¯èƒ½ãª .NET Core 3.1 ã¨ã—ã¦ãŠãã¾ã™ã€‚

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆå¾Œã« `F5` ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦å®Ÿè¡Œã•ã‚ŒãŸãªã‚‰OKã§ã™ã€‚

### å•é¡Œã‚’è§£ã
ã“ã‚Œã§ç°¡å˜ãªå•é¡Œã¯è§£ã‘ã‚‹ã¯ãšã§ã™ã€‚

ä¾‹ã¨ã—ã¦ AtCoder ã® practice contest ã‚’è§£ã„ã¦ã¿ã¾ã™ã€‚
https://atcoder.jp/contests/practice/tasks/practice_1

```csharp
using System;
using System.Linq;

internal class Program
{
    static void Main()
    {
        int a = int.Parse(Console.ReadLine());
        int[] bc = Console.ReadLine().Split().Select(int.Parse).ToArray();
        string s = Console.ReadLine();
        Console.WriteLine($"{a + bc[0] + bc[1]} {s}");
    }
}
```

## ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†

AtCoder ã®å•é¡Œã¯ [AtCoder Library(ACL)](https://github.com/atcoder/ac-library/) ã‚’å‰æã¨ã—ã¦ã„ã‚‹ã‚‚ã®ã‚‚å¤šãã‚ã‚Šã¾ã™ã€‚

ã¨ã„ã†ã“ã¨ã§ã€AtCoder Library Practice Contest ã®å•é¡Œã‚’è§£ã„ã¦æå‡ºã™ã‚‹ç’°å¢ƒã‚’æ•´ãˆã¾ã™ã€‚

### NuGetã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

ã¾ãšã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è¿½åŠ ã—ã¾ã™ã€‚

å³ã®ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã§ä½œæˆã—ãŸãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å³ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ŒNuGetãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ç®¡ç†ã€ã§NuGetç®¡ç†ç”»é¢ã‚’é–‹ãã¾ã™ã€‚

ã€Œå‚ç…§ã€ã‚¿ãƒ–ã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãŸã„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ¤œç´¢ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
![](https://storage.googleapis.com/zenn-user-upload/fea0164b43c1-20220223.png)

ã“ã“ã§ã¯ä¸‹è¨˜ã®2ã¤ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚

- [ac-library-csharp](https://github.com/kzrnm/ac-library-csharp)
- [SourceExpander](https://github.com/kzrnm/SourceExpander)

ac-library-csharp ã¯ ACL ã® C#ç§»æ¤ã€SourceExpander ã¯æå‡ºç”¨ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚

:::details ä½œæˆã—ãŸ csproj
```xml:ä½œæˆã—ãŸ csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp3.1</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="ac-library-csharp" Version="1.9.1" />
    <PackageReference Include="SourceExpander" Version="4.0.2" />
  </ItemGroup>

</Project>
```
:::


### ACL ã‚’ä½¿ã£ã¦å•é¡Œã‚’è§£ã

AtCoder Library Practice Contest ã®å•é¡Œã‚’ ac-library-csharp ã‚’ä½¿ã£ã¦è§£ã„ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

https://atcoder.jp/contests/practice2/tasks/practice2_a

:::details Program.cs
```csharp:Program.cs
using AtCoder;
using System;
using System.Linq;

internal class Program
{
    static void Main()
    {
        SourceExpander.Expander.Expand();

        int n, Q;
        var line = Console.ReadLine().Split();
        n = int.Parse(line[0]);
        Q = int.Parse(line[1]);

        var dsu = new DSU(n);

        for (int i = 0; i < Q; i++)
        {
            var query = Console.ReadLine().Split().Select(int.Parse).ToArray();
            if (query[0] == 0)
                dsu.Merge(query[1], query[2]);
            else
                Console.WriteLine(dsu.Same(query[1], query[2]) ? 1 : 0);
        }
    }
}
```
:::

`SourceExpander.Expander.Expand();` ã«ã‚ˆã£ã¦ã€å®Ÿè¡Œã—ãŸãƒ•ã‚¡ã‚¤ãƒ«(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã¾ã¾ãªã‚‰ Program.cs)ã¨åŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã« Combined.csx ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚

:::details Combined.csx
```csharp:Combined.csx
using AtCoder;
using AtCoder.Internal;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
internal class Program
{
    static void Main()
    {
        SourceExpander.Expander.Expand();

        int n, Q;
        var line = Console.ReadLine().Split();
        n = int.Parse(line[0]);
        Q = int.Parse(line[1]);

        var dsu = new DSU(n);

        for (int i = 0; i < Q; i++)
        {
            var query = Console.ReadLine().Split().Select(int.Parse).ToArray();
            if (query[0] == 0)
            {
                dsu.Merge(query[1], query[2]);
            }
            else
            {
                Console.WriteLine(dsu.Same(query[1], query[2]) ? 1 : 0);
            }
        }
    }
}
#region Expanded by https://github.com/kzrnm/SourceExpander
namespace AtCoder{public class DSU{internal readonly int _n;public readonly int[]_parentOrSize;public DSU(int n){_n=n;_parentOrSize=new int[n];_parentOrSize.AsSpan().Fill(-1);}public int Merge(int a,int b){int x=Leader(a),y=Leader(b);if(x==y)return x;if(-_parentOrSize[x]<-_parentOrSize[y])(x,y)=(y,x);_parentOrSize[x]+=_parentOrSize[y];_parentOrSize[y]=x;return x;}public bool Same(int a,int b){return Leader(a)==Leader(b);}public int Leader(int a){if(_parentOrSize[a]<0)return a;while(0<=_parentOrSize[_parentOrSize[a]]){(a,_parentOrSize[a])=(_parentOrSize[a],_parentOrSize[_parentOrSize[a]]);}return _parentOrSize[a];}public int Size(int a){return-_parentOrSize[Leader(a)];}public int[][]Groups(){int[]leaderBuf=new int[_n];int[]id=new int[_n];var resultList=new SimpleList<int[]>(_n);for(int i=0;i<leaderBuf.Length;i++){leaderBuf[i]=Leader(i);if(i==leaderBuf[i]){id[i]=resultList.Count;resultList.Add(new int[-_parentOrSize[i]]);}}var result=resultList.ToArray();int[]ind=new int[result.Length];for(int i=0;i<leaderBuf.Length;i++){var leaderID=id[leaderBuf[i]];result[leaderID][ind[leaderID]]=i;ind[leaderID]++;}return result;}}}
namespace AtCoder.Internal{public class SimpleList<T>:IList<T>,IReadOnlyList<T>{private T[]data;private const int DefaultCapacity=2;public SimpleList(){data=new T[DefaultCapacity];}public SimpleList(int capacity){data=new T[Math.Max(capacity,DefaultCapacity)];}public SimpleList(IEnumerable<T>collection){if(collection is ICollection<T>col){data=new T[col.Count];col.CopyTo(data,0);Count=col.Count;}else{data=new T[DefaultCapacity];foreach(var item in collection)Add(item);}}public Memory<T>AsMemory()=>new Memory<T>(data,0,Count);public Span<T>AsSpan()=>new Span<T>(data,0,Count);public ref T this[int index]{[MethodImpl(MethodImplOptions.AggressiveInlining)]get{if((uint)index>=(uint)Count)ThrowIndexOutOfRangeException();return ref data[index];}}public int Count{get;private set;}public void Add(T item){if((uint)Count>=(uint)data.Length)Array.Resize(ref data,data.Length<<1);data[Count++]=item;}public void RemoveLast(){if( --Count<0)ThrowIndexOutOfRangeException();}public SimpleList<T>Reverse(){Array.Reverse(data,0,Count);return this;}public SimpleList<T>Reverse(int index,int count){Array.Reverse(data,index,count);return this;}public SimpleList<T>Sort(){Array.Sort(data,0,Count);return this;}public SimpleList<T>Sort(IComparer<T>comparer){Array.Sort(data,0,Count,comparer);return this;}public SimpleList<T>Sort(int index,int count,IComparer<T>comparer){Array.Sort(data,index,count,comparer);return this;}public void Clear()=>Count=0;public bool Contains(T item)=>IndexOf(item)>=0;public int IndexOf(T item)=>Array.IndexOf(data,item,0,Count);public void CopyTo(T[]array,int arrayIndex)=>Array.Copy(data,0,array,arrayIndex,Count);public T[]ToArray()=>AsSpan().ToArray();bool ICollection<T>.IsReadOnly=>false;T IList<T>.this[int index]{get=>data[index];set=>data[index]=value;}T IReadOnlyList<T>.this[int index]{get=>data[index];}void IList<T>.Insert(int index,T item)=>throw new NotSupportedException();bool ICollection<T>.Remove(T item)=>throw new NotSupportedException();void IList<T>.RemoveAt(int index)=>throw new NotSupportedException();IEnumerator IEnumerable.GetEnumerator()=>((IEnumerable<T>)this).GetEnumerator();IEnumerator<T>IEnumerable<T>.GetEnumerator(){for(int i=0;i<Count;i++)yield return data[i];}public Span<T>.Enumerator GetEnumerator()=>AsSpan().GetEnumerator();private static void ThrowIndexOutOfRangeException()=>throw new IndexOutOfRangeException();}}
namespace SourceExpander{public class Expander{[Conditional("EXP")]public static void Expand(string inputFilePath=null,string outputFilePath=null,bool ignoreAnyError=true){}public static string ExpandString(string inputFilePath=null,bool ignoreAnyError=true){return "";}}}
#endregion Expanded by https://github.com/kzrnm/SourceExpander
```
:::

Combined.csx ã« ac-library-csharp ã®ã‚³ãƒ¼ãƒ‰ã‚‚åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚’ã¾ã‚‹ã”ã¨æå‡ºã™ã‚Œã°OKã§ã™ã€‚
ãƒ€ãƒŸãƒ¼ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒåŸ‹ã‚è¾¼ã¾ã‚Œã‚‹ã®ã§æå‡ºæ™‚ã«ã¯å½±éŸ¿ã‚ã‚Šã¾ã›ã‚“ã€‚

æå‡ºä¾‹
https://atcoder.jp/contests/practice2/submissions/29607025

### Competitive.IO

`Console.ReadLine` ã‚„ `Console.WriteLine` ã¯æ•°ãŒå¤šã„ã¨éå¸¸ã«é…ããªã£ã¦ã—ã¾ã†ã®ã§ TLE ã—ã¦ã—ã¾ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

å¤§é‡ã®å…¥å‡ºåŠ›ã§é«˜é€ŸåŒ–ã‚’å›³ã£ãŸ [Competitive.IO](https://github.com/kzrnm/Competitive.IO) ã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œæˆã—ã¦ã„ã‚‹ã®ã§è‰¯ã‹ã£ãŸã‚‰ä½¿ã£ã¦ãã ã•ã„ã€‚
ã‚‚ã¡ã‚ã‚“ SourceExpander ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚

## ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œã‚‹

ç«¶ãƒ—ãƒ­ã‚’ã‚„ã£ã¦ã„ã‚‹ã¨è‡ªä½œãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œã‚ŠãŸããªã‚‹ã‹ã¨æ€ã„ã¾ã™ã€‚

ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ãƒ¼ã§ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å³ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ã€Œè¿½åŠ ã€â†’ã€Œæ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã€ã§ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç”¨ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã—ã‚‡ã†ã€‚

**æ³¨æ„**: å®Ÿè¡Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œæˆã—ãŸå ´åˆã¯ SourceExpander ãŒå‹•ä½œã—ã¾ã›ã‚“ã€‚ä»•æ§˜ä¸Šã®åˆ¶ç´„ã‹ã‚‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯å®Ÿè¡Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¨åˆ¥ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã§ã™ã€‚

ä½œæˆã—ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã« SourceExpander.Embedder ã®å‚ç…§ã‚’è¿½åŠ ã™ã‚Œã°ã€è‡ªå‹•ã§å±•é–‹ã•ã‚Œã¾ã™ã€‚

è‡ªä½œãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ ac-library-csharp ã‚’ä½¿ã„ãŸã‘ã‚Œã°ã€ac-library-csharp ã®å‚ç…§ã‚’è¿½åŠ ã™ã‚Œã°OKã§ã™ã€‚

### è‡ªä½œãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä¾‹

æœ€å¤§å…¬ç´„æ•°ã‚’æ±‚ã‚ã‚‹é–¢æ•°ã‚’ä½¿ã£ã¦ã¿ã¾ã™ã€‚

```csharp:ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
namespace CompetitiveKaisetsu.Library
{
    public static class MathLibEx
    {
        /// <summary>
        /// æœ€å¤§å…¬ç´„æ•°
        /// </summary>
        public static int Gcd(int a, int b) => b > a ? Gcd(b, a) : (b == 0 ? a : Gcd(b, a % b));
        /// <summary>
        /// æœ€å¤§å…¬ç´„æ•°
        /// </summary>
        public static long Gcd(long a, long b) => b > a ? Gcd(b, a) : (b == 0 ? a : Gcd(b, a % b));
    }
}
```

```csharp:å®Ÿè¡Œå´
internal class Program
{
    static void Main()
    {
        SourceExpander.Expander.Expand();
        CompetitiveKaisetsu.Library.MathLibEx.Gcd(22, 7);
    }
}
```

```csharp:Combined.csx
using System.Diagnostics;
internal class Program
{
    static void Main()
    {
        SourceExpander.Expander.Expand();

        CompetitiveKaisetsu.Library.MathLibEx.Gcd(22, 7);
    }
}
#region Expanded by https://github.com/kzrnm/SourceExpander
namespace CompetitiveKaisetsu.Library { public static class MathLibEx { public static int Gcd(int a, int b) => b > a ? Gcd(b, a) : (b == 0 ? a : Gcd(b, a % b)); public static long Gcd(long a, long b) => b > a ? Gcd(b, a) : (b == 0 ? a : Gcd(b, a % b)); } }
namespace SourceExpander{public class Expander{[Conditional("EXP")]public static void Expand(string inputFilePath=null,string outputFilePath=null,bool ignoreAnyError=true){}public static string ExpandString(string inputFilePath=null,bool ignoreAnyError=true){return "";}}}
#endregion Expanded by https://github.com/kzrnm/SourceExpander
```

:::details csproj ã®ä¾‹
```xml:è‡ªä½œãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp3.1</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="ac-library-csharp" Version="1.9.1" />
    <PackageReference Include="SourceExpander.Embedder" Version="4.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

</Project>
```

```xml:å®Ÿè¡Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã® csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp3.1</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="ac-library-csharp" Version="1.9.1" />
    <PackageReference Include="SourceExpander" Version="4.0.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\CompetitiveKaisetsu.Library\CompetitiveKaisetsu.Library.csproj" />
  </ItemGroup>

</Project>

```
:::